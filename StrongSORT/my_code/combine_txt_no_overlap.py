import os
from tqdm import tqdm
from pycocotools import mask as cocomask
import cv2
import numpy as np

# this file combine_txt_no_verlap.py is to
# combine mots_seg_track txt outputs of each class to one file,
# and make the overlapping pixels only belong to one object.
# Overlap rule: assign pixels to the object with smaller area.
# this file combine_txt_no_verlap.py is from G:\github\iou-tracker\combine_txt_no_overlap.py.

val_in_trainval_seqmap=[2,6,7,8,10,13,14,16,18]
seqmap=val_in_trainval_seqmap

def get_RLE(line_one):
    split_all=line_one.split(' ')
    RLE={'size':[int(split_all[3]),int(split_all[4])],'counts':split_all[5]}
    return RLE

file_dir="../my_data/reid_one_class_infer_pair_warp_right_track/COCO_pretrain_strong/search_for_loss_combination/long_epoch_seq_shuffle_fl_2_lr_0_0001_bs_4_eval_40_no_color_sim_pretrain_weights_v3_time_7/BoxInst_MS_R_50_1x_kitti_mots/to_mots_txt/iter_0007919/mots_seg_track/DeepSORT/val_in_trainval/mask_min_det_conf_04/"
for seq_one in tqdm(seqmap):
    car_file=file_dir+'car/'+str(seq_one).zfill(4)+'.txt'
    pedestrian_file=file_dir+'pedestrian/'+str(seq_one).zfill(4)+'.txt'
    file_inputs=[car_file,pedestrian_file]
    out_dir=file_dir+'both_car_pedestrian_no_overlap/'
    # out_dir=file_dir+'tt/'
    out_path=out_dir+str(seq_one).zfill(4)+'.txt'
    os.makedirs(out_dir,exist_ok=True)
    
    with open(car_file,'r') as f:
        # read to a list and remove ending line character.
        car_content=f.read().splitlines()
    with open(pedestrian_file,'r') as f:
        ped_content=f.read().splitlines()

    # need to get the max frame id.
    combine_content=car_content+ped_content
    frame_list=[int(x.split(' ')[0]) for x in combine_content]
    max_frame=max(frame_list)
    
    # below deal with the overlapping in one same frame.
    combine_content_sort=sorted(combine_content,key=lambda x: int(x.split(' ')[0]))
    new_content=[]
    frame_overlap=[]
    for frame_id in range(0,max_frame+1):
        frame_one_content=list(filter(lambda x: int(x.split(' ')[0])==frame_id,combine_content_sort))
        # skip if the frame has no mask output.
        if not len(frame_one_content):
            continue
        # compute area and sort by it.
        area_list=[]
        for item in frame_one_content:
            RLE=get_RLE(item)
            area_list.append(cocomask.area(RLE))
        objects_sort=[x for _,x in sorted(zip(area_list,frame_one_content))]
        
        objects_disjoint = [objects_sort[0]]
        used_pixels = get_RLE(objects_sort[0])
        for obj in objects_sort[1:]:
            new_mask = get_RLE(obj)
            # for cocomask.merge func, the argument intersect=1 gets intersection part, else gets union part,
            # this is defined in coco official repo-common/maskApi.c.
            if cocomask.area(cocomask.merge([used_pixels, get_RLE(obj)], intersect=True)) > 0.0:
                obj_mask_decoded = cocomask.decode(get_RLE(obj))
                used_pixels_decoded = cocomask.decode(used_pixels)
                # below remove the overlapping pixels.
                obj_mask_decoded[np.where(used_pixels_decoded > 0)] = 0
                # have to decode bytes to string, since cocomask.encode(obj_mask_decoded) outputs bytes,
                # and bytes starts with b', the b' at the begining has to be removed,
                # and then its remaining part is the content could be converted to string.
                new_mask = cocomask.encode(obj_mask_decoded)
                new_mask['counts']=new_mask['counts'].decode('UTF-8')
                frame_overlap.append(frame_id)
            used_pixels = cocomask.merge([used_pixels, get_RLE(obj)], intersect=False)
            # str(new_mask['counts']) is to change bytes type counts,
            # generated by new_mask = cocomask.encode(obj_mask_decoded), to string.
            obj_refine=' '.join(obj.split(' ')[:3]+[str(new_mask['size'][0]),str(new_mask['size'][1]),new_mask['counts']])
            objects_disjoint.append(obj_refine)
        new_content.extend(objects_disjoint)
        
        # print(frame_id)
    print(f"Seq {str(seq_one).zfill(4)} has overlap frame: ", frame_overlap)
    
    with open(out_path,'w') as outfile:
        for line in new_content:
            line_split=line.split(' ')
            if int(line_split[2])==2:
                line_split[1]=str(int(line_split[1])+1000)
            line_out=' '.join(line_split)+'\n'
            outfile.write(line_out)

