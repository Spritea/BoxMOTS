import os
from tqdm import tqdm
from pycocotools import mask as cocomask
import cv2
import numpy as np

# this file combine_txt_no_verlap.py is to
# combine mots_seg_track txt outputs of each class to one file,
# and make the overlapping pixels only belong to one object.
# Overlap rule: assign pixels to the object with smaller area.
# this file combine_txt_no_verlap.py is from G:\github\iou-tracker\combine_txt_no_overlap.py.

val_in_trainval_seqmap=list(range(1,33))
seqmap=val_in_trainval_seqmap

def get_RLE(line_one):
    split_all=line_one.split(' ')
    RLE={'size':[int(split_all[3]),int(split_all[4])],'counts':split_all[5]}
    return RLE
def load_txt_all_class_seq_one(file_dir,seq_one):
    def load_txt_one_class_seq_one(file_dir,seq_one,one_class):
        one_class_file = file_dir+one_class+'/'+str(seq_one).zfill(4)+'.txt'
        with open(one_class_file,'r') as f:
            # read to a list and remove ending line character.
            one_class_content=f.read().splitlines()
        return one_class_content
    class_list = ['bicycle','bus','car','motorcycle','pedestrian','rider','truck']
    combine_content = []
    for one_class in class_list:
        one_class_content = load_txt_one_class_seq_one(file_dir,seq_one,one_class)
        combine_content.extend(one_class_content)
    return combine_content

file_dir="../my_data_bdd/reid_one_class_infer_bdd_pair_warp_right_track_reid_eval_in_train/COCO_pretrain_strong/iter_21k_seq_shuffle_fl_2_lr_0_001_bs_4_eval_500_no_color_sim/BoxInst_MS_R_50_1x_kitti_mots/to_mots_txt/iter_0014999/mots_seg_track/DeepSORT/val_in_trainval/mask_min_det_conf_04_bus_conf_06/shadow_filter_result_rate_02_car_truck/"
for seq_one in tqdm(seqmap):
    out_dir=file_dir+'all_class_no_overlap/'
    # out_dir=file_dir+'tt/'
    out_path=out_dir+str(seq_one).zfill(4)+'.txt'
    os.makedirs(out_dir,exist_ok=True)

    combine_content = load_txt_all_class_seq_one(file_dir,seq_one)
    # need to get the max frame id.
    frame_list=[int(x.split(' ')[0]) for x in combine_content]
    max_frame=max(frame_list)
    
    # below deal with the overlapping in one same frame.
    combine_content_sort=sorted(combine_content,key=lambda x: int(x.split(' ')[0]))
    new_content=[]
    frame_overlap=[]
    for frame_id in range(1,max_frame+1):
    # for frame_id in range(0,max_frame+1):
        frame_one_content=list(filter(lambda x: int(x.split(' ')[0])==frame_id,combine_content_sort))
        # skip if the frame has no mask output.
        if not len(frame_one_content):
            continue
        # compute area and sort by it.
        area_list=[]
        for item in frame_one_content:
            RLE=get_RLE(item)
            area_list.append(cocomask.area(RLE))
        objects_sort=[x for _,x in sorted(zip(area_list,frame_one_content))]
        
        objects_disjoint = [objects_sort[0]]
        used_pixels = get_RLE(objects_sort[0])
        for obj in objects_sort[1:]:
            new_mask = get_RLE(obj)
            # for cocomask.merge func, the argument intersect=1 gets intersection part, else gets union part,
            # this is defined in coco official repo-common/maskApi.c.
            if cocomask.area(cocomask.merge([used_pixels, get_RLE(obj)], intersect=True)) > 0.0:
                obj_mask_decoded = cocomask.decode(get_RLE(obj))
                used_pixels_decoded = cocomask.decode(used_pixels)
                # below remove the overlapping pixels.
                obj_mask_decoded[np.where(used_pixels_decoded > 0)] = 0
                # have to decode bytes to string, since cocomask.encode(obj_mask_decoded) outputs bytes,
                # and bytes starts with b', the b' at the begining has to be removed,
                # and then its remaining part is the content could be converted to string.
                new_mask = cocomask.encode(obj_mask_decoded)
                new_mask['counts']=new_mask['counts'].decode('UTF-8')
                frame_overlap.append(frame_id)
            used_pixels = cocomask.merge([used_pixels, get_RLE(obj)], intersect=False)
            # str(new_mask['counts']) is to change bytes type counts,
            # generated by new_mask = cocomask.encode(obj_mask_decoded), to string.
            obj_refine=' '.join(obj.split(' ')[:3]+[str(new_mask['size'][0]),str(new_mask['size'][1]),new_mask['counts']])
            objects_disjoint.append(obj_refine)
        new_content.extend(objects_disjoint)
        
        # print(frame_id)
    print(f"Seq {str(seq_one).zfill(4)} has overlap frame: ", frame_overlap)
    
    with open(out_path,'w') as outfile:
        for line in new_content:
            line_split=line.split(' ')
            if int(line_split[2])==2:
                line_split[1]=str(int(line_split[1])+1000)
            line_out=' '.join(line_split)+'\n'
            outfile.write(line_out)

