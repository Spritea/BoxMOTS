import numpy as np
from utils import iou,linear_assignment
import os
from tqdm import tqdm
import argparse

# this file match_mask_to_box.py is to match box based tracking result txt to 
# paired mask in mots_det_seg txt.

def deal_seq_one(track_txt_file,mask_txt_file,cat_choose,out_path,det_min_conf):
    
    # track_txt_file="../results/my_debug/car/0002.txt"
    # mask_txt_file="../my_data/reid_infer/CondInst_MS_R_50_1x_kitti_mots/to_mots_txt/mots_det_seg/val_in_trainval/car/0002.txt"
    np_track=np.loadtxt(track_txt_file,dtype=np.float64,delimiter=',')
    # since negative values could appear in x,y in np_track
    # np_track[np_track[:,2]<0,2]=0
    # np_track[np_track[:,3]<0,3]=0

    if len(np_track)==0:
        # some seqs don't have track results for ped.
        with open(out_path,'w') as f:
            f.writelines([])
        return
    
    with open(mask_txt_file,'r') as f:
        # read to a list and remove ending line character.
        mask_content=f.read().splitlines()
    frame_ids=np.unique((np_track[:,0]))
    # deepsort setting.
    # need change this.
    # det_min_conf=0.6
    # my setting, the shift caused by kaiman filter is usually not large.
    iou_threshold=0.1

    out_seq=[]
    for frame_id in frame_ids:
        np_track_frame_one=np_track[np_track[:,0]==frame_id,:]
        boxes_in_track=np_track_frame_one[:,2:6]

        frame_one_in_det=list(filter(lambda x: int(x.split(',')[0])==frame_id,mask_content))
        frame_one_in_det=list(filter(lambda x: float(x.split(',')[6])>=det_min_conf,frame_one_in_det))
        # list(map(int,x.split(',')[2:6])) is to convert string in a list to int.
        boxes_in_det=[list(map(int,x.split(',')[2:6])) for x in frame_one_in_det]
        
        # note: len(boxes_in_track) could > len(boxes_in_det),
        # since some boxes are generated by kalman filter.  
        iou_matrix = np.zeros((len(boxes_in_track), len(boxes_in_det)), dtype=np.float32)
        for d, det in enumerate(boxes_in_track):
            for t, trk in enumerate(boxes_in_det):
                iou_matrix[d, t] = iou(det, trk,box_mode='xywh')

        matched_indices = linear_assignment(-iou_matrix)
        matches = []
        for m in matched_indices:
            if iou_matrix[m[0], m[1]] >= iou_threshold:
                matches.append(m)

        # out: frame,track_id,class,height,width,rle.
        # class: car-1, ped-2.
        if len(matches)==0:
            continue
        for match_one in matches:
            track_box_id=match_one[0]
            det_box_id=match_one[1]
            track_id=np_track_frame_one[track_box_id][1]
            h_w_rle=frame_one_in_det[det_box_id].split(',')[-3:]
            out_one=[int(frame_id),int(track_id),cat[cat_choose],h_w_rle[0],h_w_rle[1],h_w_rle[2]]
            out_one=' '.join(list(map(str,out_one)))+'\n'
            out_seq.append(out_one)
    
    with open(out_path,'w') as f:
        f.writelines(out_seq)

if __name__=="__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('--track_txt_dir',type=str,required=True)
    parser.add_argument('--mask_txt_dir',type=str,required=True)
    parser.add_argument('--out_dir',type=str,required=True)
    args = parser.parse_args()
    track_txt_dir = args.track_txt_dir
    mask_txt_dir = args.mask_txt_dir
    out_dir = args.out_dir
    
    # cat={'car':1,'pedestrian':2}
    # cat_choose='pedestrian'
    # the my_code/match_mask_to_box_old.py uses det_min_conf same with the one used in DeepSORT,
    # but that's wrong, since here we use det_min_conf to filter mask, even a box is removed in DeepSORT due to low conf,
    # it could be recovered with kalman filter (like its previous one and later one both have high conf),
    # in this case, the box exists in the box based tracking result, but its paired mask is removed,
    # and hence can't match the box with its mask, so we just set the mask_det_min_conf as 0.0,
    # and use all masks to match the box.
    mask_det_min_conf=0.4
    val_in_trainval_seqmap=list(range(1,33))
    cat={'pedestrian':1,'rider':2,'car':3,'truck':4,'bus':5,'motorcycle':7,'bicycle':8}
    # track_txt_dir="../my_data_bdd/reid_one_class_infer_for_train/repeat_results/long_epoch_seq_shuffle_fl_2_lr_0_0001_eval_500_steps_4k/CondInst_MS_R_50_1x_kitti_mots/results_mot/iter_0020999/DeepSORT/min_det_conf_06/"
    # mask_txt_dir="../my_data_bdd/reid_one_class_infer_for_train/repeat_results/long_epoch_seq_shuffle_fl_2_lr_0_0001_eval_500_steps_4k/CondInst_MS_R_50_1x_kitti_mots/to_mots_txt/iter_0020999/mots_det_seg/val_set/"
    # out_dir="../my_data_bdd/reid_one_class_infer_for_train/repeat_results/long_epoch_seq_shuffle_fl_2_lr_0_0001_eval_500_steps_4k/CondInst_MS_R_50_1x_kitti_mots/to_mots_txt/iter_0020999/mots_seg_track/DeepSORT/val_set/mask_min_det_conf_04/"
    for cat_choose in cat.keys():
        os.makedirs(out_dir+cat_choose,exist_ok=True)
        for seq_id in tqdm(val_in_trainval_seqmap):
            track_txt_path=track_txt_dir+cat_choose+'/'+str(seq_id).zfill(4)+'.txt'
            mask_txt_path=mask_txt_dir+cat_choose+'/'+str(seq_id).zfill(4)+'.txt'
            out_path=out_dir+cat_choose+'/'+str(seq_id).zfill(4)+'.txt'
            deal_seq_one(track_txt_path,mask_txt_path,cat_choose,out_path,mask_det_min_conf)
