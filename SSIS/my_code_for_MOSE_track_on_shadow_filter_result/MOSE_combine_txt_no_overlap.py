# @File: StrongSORT/my_code_for_MOSE/MOSE_combine_txt_no_overlap.py 
# @Author: cws 
# @Create Date: 2024/02/24
# @Desc: Only need to remove overlap pixels.
# Do not need to combine txt result of different classes.

import os
from tqdm import tqdm
from pycocotools import mask as cocomask
import numpy as np

# this file combine_txt_no_verlap.py is to
# combine mots_seg_track txt outputs of each class to one file,
# and make the overlapping pixels only belong to one object.
# Overlap rule: assign pixels to the object with smaller area.
# this file combine_txt_no_verlap.py is from G:\github\iou-tracker\combine_txt_no_overlap.py.

def load_txt(file_name):
    with open(file_name,'r') as f:
        txt_content=f.read().splitlines()
    return txt_content

def get_RLE(line_one):
    split_all=line_one.split(' ')
    RLE={'size':[int(split_all[3]),int(split_all[4])],'counts':split_all[5]}
    return RLE

img_seqs_txt = "search_result/train_car_seq.txt"
seq_list = load_txt(img_seqs_txt)
file_dir = "for_tracking_MOSE/filter_result_MOSE/MOSE_car_seq_out_pair_warp/train_car_seq/to_mots_txt/mots_seg_track/DeepSORT/mask_min_det_conf_04_min_det_conf_06_max_age_default_30_max_cos_0.6_no_kalman_gate/shadow_filter_result_rate_02/car"
out_dir = "for_tracking_MOSE/filter_result_MOSE/MOSE_car_seq_out_pair_warp/train_car_seq/to_mots_txt/mots_seg_track/DeepSORT/mask_min_det_conf_04_min_det_conf_06_max_age_default_30_max_cos_0.6_no_kalman_gate/shadow_filter_result_rate_02/car_no_overlap"
os.makedirs(out_dir, exist_ok=True)
for seq_one in tqdm(seq_list):
    car_file = os.path.join(file_dir, seq_one+".txt")
    out_path = os.path.join(out_dir, seq_one+".txt")
    car_content = load_txt(car_file)
    combine_content = car_content
    frame_list=[int(x.split(' ')[0]) for x in combine_content]
    # one seq of MOSE could have no result.
    if len(frame_list)==0:
        print('empty seq:', seq_one)
        with open(out_path,'w') as outfile:
            pass
        continue
    max_frame=max(frame_list)
    
    # below deal with the overlapping in one same frame.
    combine_content_sort=sorted(combine_content,key=lambda x: int(x.split(' ')[0]))
    new_content=[]
    frame_overlap=[]
    for frame_id in range(0,max_frame+1):
        frame_one_content=list(filter(lambda x: int(x.split(' ')[0])==frame_id,combine_content_sort))
        # skip if the frame has no mask output.
        if not len(frame_one_content):
            continue
        # compute area and sort by it.
        area_list=[]
        for item in frame_one_content:
            RLE=get_RLE(item)
            area_list.append(cocomask.area(RLE))
        objects_sort=[x for _,x in sorted(zip(area_list,frame_one_content))]
        
        objects_disjoint = [objects_sort[0]]
        used_pixels = get_RLE(objects_sort[0])
        for obj in objects_sort[1:]:
            new_mask = get_RLE(obj)
            # for cocomask.merge func, the argument intersect=1 gets intersection part, else gets union part,
            # this is defined in coco official repo-common/maskApi.c.
            if cocomask.area(cocomask.merge([used_pixels, get_RLE(obj)], intersect=True)) > 0.0:
                obj_mask_decoded = cocomask.decode(get_RLE(obj))
                used_pixels_decoded = cocomask.decode(used_pixels)
                # below remove the overlapping pixels.
                obj_mask_decoded[np.where(used_pixels_decoded > 0)] = 0
                # have to decode bytes to string, since cocomask.encode(obj_mask_decoded) outputs bytes,
                # and bytes starts with b', the b' at the begining has to be removed,
                # and then its remaining part is the content could be converted to string.
                new_mask = cocomask.encode(obj_mask_decoded)
                new_mask['counts']=new_mask['counts'].decode('UTF-8')
                frame_overlap.append(frame_id)
            used_pixels = cocomask.merge([used_pixels, get_RLE(obj)], intersect=False)
            # str(new_mask['counts']) is to change bytes type counts,
            # generated by new_mask = cocomask.encode(obj_mask_decoded), to string.
            obj_refine=' '.join(obj.split(' ')[:3]+[str(new_mask['size'][0]),str(new_mask['size'][1]),new_mask['counts']])
            objects_disjoint.append(obj_refine)
        new_content.extend(objects_disjoint)
        
    if len(frame_overlap)>0:
        print(f"Seq {str(seq_one).zfill(4)} has overlap frame: ", frame_overlap)
    
    with open(out_path,'w') as outfile:
        for line in new_content:
            line_split=line.split(' ')
            # if int(line_split[2])==2:
            #     line_split[1]=str(int(line_split[1])+1000)
            line_out=' '.join(line_split)+'\n'
            outfile.write(line_out)
